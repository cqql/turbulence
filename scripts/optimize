#!/usr/bin/env python

import itertools
import os
import queue
import re
import shutil
import stat
import subprocess
import sys
import tempfile
from argparse import ArgumentParser
from concurrent.futures import ThreadPoolExecutor


def parseArguments():
    parser = ArgumentParser(description="Optimize PETSc arguments")
    parser.add_argument("-j",
                        "--jobs",
                        type=int,
                        default=1,
                        help="How many jobs to run in parallel")
    parser.add_argument("directory", help="Directory for runs and output")
    parser.add_argument("scenario", help="Scenario to run")

    return parser.parse_args()

# Static options to apply in any case
OPTIONS = {
    "ksp_converged_reason": True,
    "ksp_atol": 1e-6,
    "ksp_rtol": 1e-6,
    "ksp_max_it": 1e5
}


def createPetscArgs(options):
    ops = OPTIONS.copy()
    ops.update(options)

    with tempfile.NamedTemporaryFile(delete=False, mode="w") as file:
        for k, v in ops.items():
            if isinstance(v, bool) and v:
                line = "-{}".format(k)
            elif isinstance(v, float):
                line = "-{} {:f}".format(k, v)
            elif isinstance(v, str):
                line = "-{} {}".format(k, v)
            else:
                sys.exit("Unknown type for option {}".format(k))

            file.write(line + "\n")

        return file.name

# Options and possible values for different solvers
SOLVERS = [
    "chebyshev", "cg", "bicg", "gmres", "fgmres", "dgmres", "gcr", "bcgs",
    "cgs", "tfqmr", "tcqmr", "cr", "lsqr"
]

# Options and possible values for different preconditioners
PRECONDITIONERS = [
    "jacobi", "bjacobi", "sor", "eisenstat", "icc", "ilu", "asm", "gasm",
    "gamg", "bddc", "ksp", "lu", "cholesky", "none"
]


def run(ns, scenario, outdir, options):
    logfile = os.path.join(outdir, "log")

    os.makedirs(outdir)

    with open(logfile, "w") as log:
        petsc_args = createPetscArgs(options)

        subprocess.call(
            ["scripts/cluster/run", "--local", "--petsc-args", petsc_args,
             outdir, ns, scenario],
            stdout=log,
            stderr=log)

    timingfile = os.path.join(outdir, "timing", "rank-0")

    with open(timingfile, "r") as timing:
        content = timing.read()
        match = re.search("^poisson (.+)$", content, re.MULTILINE)

        if match:
            return float(match.group(1))
        else:
            return None


def main():
    arguments = parseArguments()
    arguments.directory = os.path.realpath(arguments.directory)

    if os.path.exists(arguments.directory):
        sys.exit("{} already exists".format(arguments.directory))

    os.makedirs(arguments.directory)

    dir = arguments.directory
    ns = os.path.join(dir, "ns")
    scenario = os.path.join(dir, "scenario.xml")
    evaluations = os.path.join(dir, "evaluations")

    # Copy all relevant files
    shutil.copyfile(arguments.scenario, scenario)
    shutil.copyfile(os.path.realpath("./ns"), ns)
    os.chmod(ns, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)

    combinations = list(itertools.product(SOLVERS, PRECONDITIONERS))
    n = len(combinations)
    remaining = queue.Queue()
    for c in combinations:
        remaining.put_nowait(c)

    stats = {}

    def worker():
        while True:
            try:
                solver, preconditioner = remaining.get_nowait()
            except queue.Empty:
                return

            print("{}-{}: Starting (#{} / {})".format(solver, preconditioner, n
                                                      - remaining.qsize(), n))

            outdir = os.path.join(evaluations, "{}-{}".format(solver,
                                                              preconditioner))
            options = {"ksp_type": solver,
                       "pc_type": preconditioner,
                       "sub_ksp_type": solver,
                       "sub_pc_type": preconditioner}
            time = run(ns, scenario, outdir, options)

            stats[(solver, preconditioner)] = time
            minimum = min(stats.items(), key=lambda p: p[1])
            maximum = max(stats.items(), key=lambda p: p[1])

            print("""{}-{}: Done ({} seconds)
Current Min: {}-{} ({} seconds)
Current Max: {}-{} ({} seconds)
""".format(solver, preconditioner, time, minimum[0][0], minimum[0][1], minimum[
                1], maximum[0][0], maximum[0][1], maximum[1]))

    if arguments.jobs == 1:
        worker()
    else:
        with ThreadPoolExecutor(max_workers=arguments.jobs) as executor:
            for i in range(arguments.jobs):
                executor.submit(worker)

    times = sorted(stats.values())
    confs = {time: conf for conf, time in stats.items()}

    print("# Ranking")
    for i in range(len(times)):
        time = times[i]
        conf = confs[time]
        print("{}. {}-{} ({} seconds)".format(i + 1, conf[0], conf[1], time))


if __name__ == "__main__":
    main()
